SUBROUTINE SUBNAME (MPL_RECV_REAL4) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif


REAL(KIND=JPRM) _ATTR_     :: PBUF(:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
REAL(KIND=JPRM)    :: ZDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)

#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1))) - LOC(PBUF(LBOUND(PBUF,1)))) /= 4_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL4),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL4))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL4)   

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_REAL8) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

! real_b,intent(in) :: PBUF(:)
REAL(KIND=JPRD) _ATTR_     :: PBUF(:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
REAL(KIND=JPRD)    :: ZDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1))) - LOC(PBUF(LBOUND(PBUF,1)))) /= 8_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(PBUF(1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL8),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL8))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL8) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_INT) (KBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,KOUNT,&
 &KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

INTEGER(KIND=JPIM) _ATTR_    :: KBUF(:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID,IDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(KBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(KBUF(UBOUND(KBUF,1)))-LOC(KBUF(LBOUND(KBUF,1)))) /= 4_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF
IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_INTEGER),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_INTEGER))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_INT) 

SUBROUTINE SUBNAME (MPL_RECV_INT8) (KBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,KOUNT,&
 &KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

INTEGER(KIND=JPIB) _ATTR_    :: KBUF(:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
INTEGER(KIND=JPIB) :: IDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(KBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(KBUF(UBOUND(KBUF,1)))-LOC(KBUF(LBOUND(KBUF,1)))) /= 8_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0 ) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(IDUM(1),1,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(KBUF(1),IBUFFSIZE,INT(MPI_INTEGER8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_INTEGER8),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_INTEGER8))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_INT8) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_INT2) (KBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

INTEGER(KIND=JPIM) _ATTR_    :: KBUF(:,:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID, IDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(KBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(KBUF(UBOUND(KBUF,1),UBOUND(KBUF,2))) - &
     & LOC(KBUF(LBOUND(KBUF,1),LBOUND(KBUF,2)))) /= 4_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0 ) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(IDUM(1),1,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(KBUF(1,1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(KBUF(1,1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(KBUF(1,1),IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_INTEGER),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_INTEGER))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_INT2) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_INT_SCALAR) (KINT,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

INTEGER(KIND=JPIM) _ATTR_    :: KINT
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = 1

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(KINT,IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(KINT,IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(KINT,IBUFFSIZE,INT(MPI_INTEGER),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_INTEGER),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_INTEGER))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_INT_SCALAR) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_REAL4_SCALAR) (PREAL4,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif


REAL(KIND=JPRM) _ATTR_    :: PREAL4
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = 1

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(PREAL4,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(PREAL4,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(PREAL4,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL4),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL4))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL4_SCALAR) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_REAL8_SCALAR) (PREAL8,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

REAL(KIND=JPRD) _ATTR_    :: PREAL8
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = 1

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(PREAL8,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(PREAL8,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(PREAL8,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
   & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL8),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL8))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL8_SCALAR) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_REAL42) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8, MPI_IRECV => MPI_IRECV8
#endif


REAL(KIND=JPRM) _ATTR_     :: PBUF(:,:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
REAL(KIND=JPRM)    :: ZDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1),UBOUND(PBUF,2))) - &
     & LOC(PBUF(LBOUND(PBUF,1),LBOUND(PBUF,2)))) /= 4_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(ZDUM(1),1,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL4),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL4))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL42)   

SUBROUTINE SUBNAME (MPL_RECV_REAL43) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

REAL(KIND=JPRM) _ATTR_     :: PBUF(:,:,:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)

IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1),UBOUND(PBUF,2),UBOUND(PBUF,3))) - &
     & LOC(PBUF(LBOUND(PBUF,1),LBOUND(PBUF,2),LBOUND(PBUF,3)))) /= 4_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(PBUF,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(PBUF,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(PBUF,IBUFFSIZE,INT(MPI_REAL4),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL4),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL4))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL43) 


!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_REAL82) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

REAL(KIND=JPRD) _ATTR_     :: PBUF(:,:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
REAL(KIND=JPRD)    :: ZDUM(1)
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)
#ifndef NAG
IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1),UBOUND(PBUF,2))) - &
     & LOC(PBUF(LBOUND(PBUF,1),LBOUND(PBUF,2)))) /= 8_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF
#endif

IF(IBUFFSIZE == 0) THEN
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(ZDUM(1),1,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ELSE
  IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
    CALL MPI_RECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
    CALL MPI_RECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
  ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
    CALL MPI_IRECV(PBUF(1,1),IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
     & KREQUEST,IERROR)
  ELSE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL8),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL8))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL82) 

SUBROUTINE SUBNAME (MPL_RECV_REAL83) (PBUF,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

REAL(KIND=JPRD) _ATTR_     :: PBUF(:,:,:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = SIZE(PBUF)

IF (IBUFFSIZE > 0) THEN
  IF( (LOC(PBUF(UBOUND(PBUF,1),UBOUND(PBUF,2),UBOUND(PBUF,3))) - &
     & LOC(PBUF(LBOUND(PBUF,1),LBOUND(PBUF,2),LBOUND(PBUF,3)))) /= 8_JPIB*(IBUFFSIZE - 1) ) THEN
    CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV: BUFFER NOT CONTIGUOUS ',LDABORT=LLABORT)
  ENDIF
ENDIF

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(PBUF,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(PBUF,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(PBUF,IBUFFSIZE,INT(MPI_REAL8),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_REAL8),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_REAL8))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_REAL83) 

!     ------------------------------------------------------------------

SUBROUTINE SUBNAME (MPL_RECV_CHAR_SCALAR) (CDCHAR,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

CHARACTER(LEN=*) _ATTR_ :: CDCHAR
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = LEN(CDCHAR)

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_BYTE),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_BYTE))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_CHAR_SCALAR) 

SUBROUTINE SUBNAME (MPL_RECV_CHAR) (CDCHAR,KSOURCE,KTAG,KCOMM,KFROM,KRECVTAG,&
 &KOUNT,KMP_TYPE,KERROR,KREQUEST,CDSTRING)

#ifdef USE_8_BYTE_WORDS
  USE MPI4TO8, ONLY : &
    MPI_RECV => MPI_RECV8,  MPI_IRECV => MPI_IRECV8
#endif

CHARACTER(LEN=*) _ATTR_ :: CDCHAR(:)
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: KTAG,KCOMM,KMP_TYPE,KSOURCE
INTEGER(KIND=JPIM),INTENT(OUT),OPTIONAL :: KREQUEST,KERROR,KFROM,KRECVTAG,KOUNT
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER(KIND=JPIM) :: IBUFFSIZE,IMP_TYPE,ICOMM,IERROR 
INTEGER(KIND=JPIM) :: ISOURCE,ITAG
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLABORT=.TRUE.
INTEGER(KIND=JPIM) :: ITID
ITID = OML_MY_THREAD()

CALL MPL_RECV_PREAMB(IMP_TYPE,ICOMM,ISOURCE,ITAG,KMP_TYPE,KCOMM,KSOURCE,KTAG,KREQUEST)

IBUFFSIZE = LEN(CDCHAR) * SIZE(CDCHAR)

IF(IMP_TYPE == JP_BLOCKING_STANDARD) THEN
  CALL MPI_RECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
  CALL MPI_RECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM,IRECV_STATUS,IERROR)
ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD) THEN
  CALL MPI_IRECV(CDCHAR,IBUFFSIZE,INT(MPI_BYTE),ISOURCE,ITAG,ICOMM, &
    & KREQUEST,IERROR)
ELSE
  CALL MPL_MESSAGE(CDMESSAGE='MPL_RECV:ILLEGAL MP_TYPE ',LDABORT=LLABORT)
ENDIF

IF(IMP_TYPE /= JP_NON_BLOCKING_STANDARD) THEN
  CALL MPL_RECV_TAIL(IRECV_STATUS,INT(MPI_BYTE),KFROM,KOUNT,KRECVTAG,KERROR,CDSTRING)
ELSE
  IF(LMPLSTATS) CALL MPL_RECVSTATS(IBUFFSIZE,INT(MPI_BYTE))
ENDIF

END SUBROUTINE SUBNAME (MPL_RECV_CHAR) 


